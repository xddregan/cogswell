<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<div class="slidecontainer">
			<p style="color:green">Value to be used for control</p>
		  <input type="range" min="0" max="360" value="0" class="slider" id="myRange">
		  <p style="color:red">Value: <span id="showValue"> </span></p>
			</div>



		<script src="js/three.js"></script>

		<script>
			var camera, scene, renderer;
			var mesh;
			var delta = 0.0;
			var slider = document.getElementById("myRange");
			var showValue = document.getElementById("showValue");
			var slideValue = slider.value;
			slider.oninput = function() {
				  slideValue = this.value;
				showValue.innerHTML = this.value;
			}
			init();
			animate();
			function init() {
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.y = 2;
				camera.position.z = 5;
				scene = new THREE.Scene();
				//var texture = new THREE.TextureLoader().load( 'textures/crate.gif' );
				var geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );

				//var material = new THREE.MeshBasicMaterial( { map: texture } );
				var material = new THREE.MeshNormalMaterial(  );
				mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				//
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate() {
				requestAnimationFrame( animate );
				//mesh.rotation.x += 0.005;
				//mesh.rotation.y += 0.01;
				updateMeshMatrixRotate();
				renderer.render( scene, camera );
			}
			function updateMeshMatrixTranslate()
			{
				var m = new THREE.Matrix4();
				var m11 = 1.0; var m12 = 0.0; var m13 = 0.0; var m14 = 0.0;
				var m21 = 0.0; var m22 = 1.0; var m23 = 0.0; var m24 = 0.0;
			    var m31 = 0.0; var m32 = 0.0; var m33 = 1.0; var m34 = 0.0;
				var m41 = 0.0 + delta; var m42 = 0.0; var m43 = 0.0; var m44 = 1.0;

				delta += 0.002;


				// the order here seems differnt
				m.set( m11, m21, m31, m41,
					   m12, m22, m32, m42,
					   m13, m23, m33, m43,
					   m14, m24, m34, m44 );

				mesh.matrixAutoUpdate = false;
				mesh.matrix =m;

			}
			function updateMeshMatrixRotate()
			{

				var m = new THREE.Matrix4();
				var m11 = Math.cos(delta);  var m12 = Math.sin(delta); var m13 = 0.0; var m14 = 0.0;
				var m21 = -Math.sin(delta); var m22 = Math.cos(delta); var m23 = 0.0; var m24 = 0.0;
			    var m31 = 0.0; var m32 = 0.0; var m33 = 1.0; var m34 = 0.0;
				var m41 = 0.0; var m42 = 0.0; var m43 = 0.0; var m44 = 1.0;

				delta = THREE.Math.degToRad(slideValue); 


				// the order here seems differnt
				m.set( m11, m21, m31, m41,
					   m12, m22, m32, m42,
					   m13, m23, m33, m43,
					   m14, m24, m34, m44 );

				mesh.matrixAutoUpdate = false;
				mesh.matrix =m;

			}

			function updateMeshMatrixRotateFromEuler()
			{

				var m = new THREE.Matrix4();
				delta += 0.002;
				var euler = new THREE.Euler(delta,0.0,0.0,"XYZ");
				m.makeRotationFromEuler(euler);

				mesh.matrixAutoUpdate = false;
				mesh.matrix =m;

			}

			
			function updateMeshMatrixRotateTranslate()
			{

				var rotateMatrix = new THREE.Matrix4();
				var translateMatrix = new THREE.Matrix4();
				var combinedMatrix = new THREE.Matrix4();
				delta += 0.002;
				var euler = new THREE.Euler(0.0,0.0,delta,"XYZ");
				rotateMatrix.makeRotationFromEuler(euler);
				translateMatrix.makeTranslation(2.0,2.0,0.0);
				
				//combinedMatrix.multiplyMatrices(translateMatrix,rotateMatrix);
				combinedMatrix.multiply(translateMatrix);	
				combinedMatrix.multiply(rotateMatrix);	

				mesh.matrixAutoUpdate = false;
				mesh.matrix =combinedMatrix;

			}





		</script>

	</body>
</html>
