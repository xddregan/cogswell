<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js ui examples</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
		</style>
	</head>
	<body>


		<script src="js/three.js"></script>
		<script src="http://threejs.org/examples/js/controls/OrbitControls.js"></script>


		<script>
			var camera, scene, renderer,controls;
			var box;
			var delta = 0.0;
			var cameraTheta = 0.0;
			var pills = [];  // TODO add pills to this array when you create them		
			var walls = [];  // TODO add walls to this array you create	
			var paddle;   // TODO need to create paddle 
			var ball;    // TODO need to create ball

			const leftSideX = -50;
			const rightSideX = 50;
			const topZ = -35;
			const bottomZ = 35;
			const numPillsX = 9;
			const numRows = 7;
			const pillHeight = 2;
			var cameraPositions = [];
			var pillWidth ;  // need to set this
			var ballDirection = new THREE.Vector3(1,0,1).normalize(); 
			var ballSpeed = 15.1;
			
			var clock = new THREE.Clock();



			init();
			animate();
			function init() {
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.x = 0;
				camera.position.y = 50;
				camera.position.z = 50;
				controls = new THREE.OrbitControls(camera);
				scene = new THREE.Scene();
				var geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );

				//var material = new THREE.MeshBasicMaterial( { map: texture } );
				//var material = new THREE.MeshNormalMaterial(  );
				//mesh = new THREE.Mesh( geometry, material );
				//scene.add( mesh );
				var light = new THREE.AmbientLight( 0x707070, 0.3 ); // soft white light
				scene.add( light );

				var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.7 );

				camera.add( directionalLight );
				scene.add( camera );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				//
				makeWorld();
				window.addEventListener( 'resize', onWindowResize, false );
				
			}


		
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate() { requestAnimationFrame( animate );
				//mesh.rotation.x += 0.005;
				//mesh.rotation.y += 0.01;
				var delta = clock.getDelta();
				//updateBallMovement(delta); //TODO uncomment line
								// once ball is created
								// once paddle is created
								// walls array is filled in
								// pills array is filled in
				controls.update();

				renderer.render( scene, camera );
			}


			function makePills()
			{
				//TODO 
				console.log("TODO makePills");
			}


			function makeWorld() {
				makePills();
				//TODO 
				console.log("TODO makeWorld");

			}	


//	Should not need to edit these functions initially as 
//  There is a slight issue where ball intersects before it bounces we can ignore this issue
			function collideBall(newPos,direction,radius,listOfObjects)
			{
				var ray = new THREE.Raycaster(newPos,direction.clone().normalize(),0,radius);		
				var collideList = ray.intersectObjects(listOfObjects);

				if ( collideList.length > 0 && collideList[0].distance < radius )
					return collideList[0];
				else
					return null;

			}

			function bounceBall(position,inDirection,contactInfo)
			{
				var face      = contactInfo.face,
					normal    = contactInfo.face.normal,
					distance  = contactInfo.distance,
					point1    = new THREE.Vector3(),
					point2    = new THREE.Vector3(),
					direction = new THREE.Vector3(),
					plainD,
					t,
					translate = new THREE.Vector3();
					

					var moveDir = inDirection.clone();
					moveDir.y = 0;
					moveDir.normalize();
					normal.y = 0;
					normal.normalize();
					console.log("normal ", normal," moveDir " , moveDir);	
					var outDirection =  moveDir.reflect(normal);
					return outDirection;

			}
					

		  	function updateBallMovement(delta)
			{
				var currPos=  ball.position.clone();	
				var currDir = ballDirection.clone();
				var newPos;
		  		var newDir;

				//console.log("ballpos",newPos);

				var wallHit  = collideBall(currPos,currDir,1+delta * ballSpeed ,walls);  				
				if ( wallHit != null)
				{
		  			console.log('wallHit ',wallHit);
					newDir = bounceBall(currPos,currDir,wallHit);  	
					newPos = currDir.multiplyScalar(wallHit.distance).add(currPos);
				}
				else
				{
					var paddleHit = collideBall(currPos,currDir,1+delta * ballSpeed ,[paddle]);  				
					if ( paddleHit != null)
					{
		  				console.log('paddleHit ',paddleHit);
						newDir = bounceBall(currPos,currDir,paddleHit);  	
						newPos = currDir.multiplyScalar(paddleHit.distance).add(currPos);
					}
		  			else
		  			{
						var pillHit = collideBall(currPos,currDir,1+delta * ballSpeed ,pills);  				
						if ( pillHit != null)
						{
		  					console.log('pillHit ',pillHit);
							newDir = bounceBall(currPos,currDir,pillHit);  	
							newPos = currDir.multiplyScalar(pillHit.distance).add(currPos);
						}
		  				else
		  				{
		  					newDir = currDir.clone();
							newPos = currDir.multiplyScalar(delta * ballSpeed).add(currPos);
		  				}
		  			}

				}

				ball.position.copy(newPos);
		  		ballDirection.copy(newDir);
				console.log("ballnewpos",ball.position,"ballnewdir",ballDirection);

		  	}




		</script>

	</body>
</html>
