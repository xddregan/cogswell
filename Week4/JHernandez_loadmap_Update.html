<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<div class="slidecontainer">
			<p style="color:green">Value to be used for control</p>
		  <input type="range" min="0" max="360" value="0" class="slider" id="myRange">
		  <p style="color:red">Value: <span id="showValue"> </span></p>
			</div>
			<--
			<div>
			
				<button onclick="setMatrixUpdate()"><font color="green">Matrix  </font></button><br>
				<button onclick="setEulerUpdate()"><font color="green">Euler   </font></button><br>
				<button onclick="setCombinedUpdate()"><font color="green">Combined</font></button><br>

			</div>
			-->

		<script src="js/three.js"></script>
		<script src="http://threejs.org/examples/js/loaders/ColladaLoader.js"></script>
		<script src="http://threejs.org/examples/js/controls/OrbitControls.js"></script>
		<script>
			var camera, scene, renderer,controls;
			var box;
			var delta = 0.0;
			var cameraTheta = 0.0;
			var slider = document.getElementById("myRange");
			var showValue = document.getElementById("showValue");
			var slideValue = slider.value;
			slider.oninput = function() {
				  slideValue = this.value;
				showValue.innerHTML = this.value;
			}
			init();
			animate();
			function init() {
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.x = 1;
				camera.position.y = 1;
				camera.position.z = 5;
				controls = new THREE.OrbitControls(camera);
				scene = new THREE.Scene();
				var texture = new THREE.TextureLoader().load( 'textures/crate.gif' );
				var geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );

				var material = new THREE.MeshBasicMaterial( { map: texture } );
				var material = new THREE.MeshNormalMaterial(  );
				mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );
				var light = new THREE.AmbientLight( 0x404040 );
				scene.add( light );
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				//
				loadBox();
				window.addEventListener( 'resize', onWindowResize, false );
				
			}
			function loadBox()
			{
			var manager = new THREE.LoadingManager();
			manager.onStart = function ( url, itemsLoaded, itemsTotal ) {

				console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );

			};

			manager.onLoad = function ( ) {

				console.log( 'Loading complete!');

			};


			manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {

				console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );

			};

			manager.onError = function ( url ) {

				console.log( 'There was an error loading ' + url );

			};	


			var loader = new THREE.ColladaLoader( manager );

			var loadedJson = loadLevelMap("data/levelmap.json");
				


			fetch("data/levelmap.json")
				  .then(response => response.json())
					.then(json => {
						
						console.log(json)
						var levelobjects = json["levelobjects"];		

						levelobjects.forEach( levelObject =>
							{
								console.log(levelObject["model"]);
								loader.load(levelObject["model"], function( collada ){
									var object = collada.scene;
									"levelmap" : [ 
									{
									// set the postion from the map 
									// set the global scale from the levelmap
									// set the height from the map iths the globalScale * height
									// set the rotationY (remember rotationy is in degrees)  
										"position": [1.0, 0.0, 0.1],
										"scale": 1.0,
										"height": globalScale * height,
										"rotationY": 45; 
									
									scene.add(object);	
								});
							});
					});
			


			}

			var fileread;
			function loadLevelMap(filename)
			{
				fileread = new FileReader();
				fileread.onload = mapjsonloaded();
				fileread.readAsText(filename);
			}

			function mapjsonloaded(e)
			{
				var text = fileread.result;  
				console.log(text);

			}


		
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate() { requestAnimationFrame( animate );
				mesh.rotation.x += 0.005;
				mesh.rotation.y += 0.01;
				controls.update();
				sceneTheta = THREE.Math.degToRad(slideValue); 

				var rotateMatrix = new THREE.Matrix4();
				var euler = new THREE.Euler(0.0,sceneTheta,0.0,"XYZ");
				rotateMatrix.makeRotationFromEuler(euler);
				scene.matrix.matrixAutoUpdate = false;
				scene.matrix = rotateMatrix;

				renderer.render( scene, camera );
			}


		
				
				fetch("data/levelmap.json")
				  .then(response => response.json())
					.then(json => {
						
						console.log(json)
						var levelobjects = json["levelobjects"];		

						levelobjects.forEach( levelObject =>
							{
								console.log(levelObject["model"]);
								loader.load(levelObject["model"],

							});
						for (var levelObject of levelobjects )
							{
								console.log(levelObject["model"]);

							};
						for (var i = 0 ; i < levelobjects.length ;i++)
						{
								console.log(levelobjects[i]["model"]);
						}
				loader.load( './data/boxscene.dae', function ( collada ) {

					var boxScene = collada.scene;
					box = boxScene.getObjectByName("Box"); 
					scene.add(box);
					for ( var i = 0; i < 1000; i ++ ) {
						var object = box.clone();
						object.position.x = Math.random() * 100 - 50;
						object.position.y = Math.random() * 100 - 50;
						object.position.z = Math.random() * 100 - 50;
						object.rotation.x = Math.random() * 2 * Math.PI;
						object.rotation.y = Math.random() * 2 * Math.PI;
						object.rotation.z = Math.random() * 2 * Math.PI;
						object.scale.x = Math.random() + 0.5;
						object.scale.y = Math.random() + 0.5;
						object.scale.z = Math.random() + 0.5;
						scene.add( object );
					}



					for ( var i = 0; i < 1000; i ++ ) {
						var geom = box.geometry;
						var instanceMaterial = new THREE.MeshBasicMaterial( 
							{color : (Math.random() * 0xffffffff)}
																	 );
						var object = new THREE.Mesh(geom,instanceMaterial);

						object.position.x = Math.random() * 100 - 50;
						object.position.y = Math.random() * 100 - 50;
						object.position.z = Math.random() * 100 - 50;
						object.rotation.x = Math.random() * 2 * Math.PI;
						object.rotation.y = Math.random() * 2 * Math.PI;
						object.rotation.z = Math.random() * 2 * Math.PI;
						object.scale.x = Math.random() + 0.5;
						object.scale.y = Math.random() + 0.5;
						object.scale.z = Math.random() + 0.5;
						scene.add( object );
					}


				} );
				





		</script>

	</body>
</html>
